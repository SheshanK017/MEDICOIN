"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.storage = exports.loadDefaultConfig = void 0;
const andromeda_js_1 = require("@andromedaprotocol/andromeda.js");
const convict_1 = __importDefault(require("convict"));
const convict_format_with_validator_1 = __importDefault(require("convict-format-with-validator"));
const storage_1 = require("./storage");
convict_1.default.addFormats(convict_format_with_validator_1.default);
/**
 * Config used by the CLI
 * Uses convict
 */
const config = (0, convict_1.default)({
    chain: {
        name: {
            default: "",
            doc: "The name of the chain config used",
            format: String,
            env: "CHAIN_CONFIG_NAME",
            nullable: false,
        },
        chainName: {
            default: "",
            doc: "The name of the chain",
            format: String,
            nullable: false,
        },
        chainId: {
            default: "",
            doc: "The ID of the chain to use",
            format: String,
            env: "CHAIN_ID",
            nullable: false,
        },
        chainUrl: {
            default: "",
            doc: "The URL of the chain to use",
            format: "url",
            env: "CHAIN_URL",
            nullable: false,
        },
        kernelAddress: {
            default: "",
            doc: "The contract address of the Andromeda Kernel",
            format: String,
            env: "REGISTRY_ADDRESS",
            nullable: false,
        },
        addressPrefix: {
            default: "",
            doc: "The prefix for all addresses on chain",
            format: String,
            nullable: false,
        },
        defaultFee: {
            default: "0.025ujunox",
            format: String,
            doc: "The default fee amount",
            nullable: false,
        },
        blockExplorerTxPages: {
            format: (Array),
            nullable: false,
            doc: "URLs to block explorers for the given chain. Must include '${txHash}'",
            validate: (val) => {
                if (!Array.isArray(val))
                    throw new Error("Explorer Tx pages must be an array");
                if (val.some((page) => typeof page !== "string"))
                    throw new Error("Not all page URLs are a string");
                if (!val.some((page) => page.includes("${txHash}")))
                    throw new Error("Tx page URLs must include '${txHash}'");
            },
            default: [""],
        },
        blockExplorerAddressPages: {
            format: (Array),
            nullable: false,
            doc: "URLs to block explorers for the given chain. Must include '${txHash}'",
            validate: (val) => {
                if (!Array.isArray(val))
                    throw new Error("Explorer Address pages must be an array");
                if (val.some((page) => typeof page !== "string"))
                    throw new Error("Not all page URLs are a string");
                if (!val.some((page) => page.includes("${address}")))
                    throw new Error("Address page URLs must include '${address}'");
            },
            default: [""],
        },
        chainType: {
            default: "mainnet",
            format: ["mainnet", "testnet"],
            doc: "The chain type",
            nullable: false,
        },
    },
});
/**
 * Loads the config used by the CLI on startup
 */
async function loadDefaultConfig() {
    try {
        const savedConfig = (0, storage_1.loadStorageFile)("config.json");
        try {
            const parsedSavedConfig = JSON.parse(savedConfig.toString());
            config.load(parsedSavedConfig);
        }
        catch (error) {
            throw new Error("Invalid config file");
        }
    }
    catch (error) {
        console.error(error);
        const defaultConfig = {
            chain: await (0, andromeda_js_1.queryChainConfig)("uni-5"),
        };
        config.load(defaultConfig);
    }
}
exports.loadDefaultConfig = loadDefaultConfig;
/**
 * Saves the current config when the CLI is exited
 */
(0, storage_1.addExitHandler)(() => {
    (0, storage_1.writeStorageFile)("config.json", JSON.stringify(config.getProperties()));
});
exports.storage = __importStar(require("./storage"));
exports.default = config;
