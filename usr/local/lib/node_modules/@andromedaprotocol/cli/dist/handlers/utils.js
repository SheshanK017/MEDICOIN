"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAddressInput = exports.generateHandler = exports.handle = exports.parseJSONInput = exports.parseInput = void 0;
const andromeda_js_1 = require("@andromedaprotocol/andromeda.js");
const picocolors_1 = __importDefault(require("picocolors"));
const cmd_1 = require("../cmd");
const common_1 = require("../common");
const config_1 = __importDefault(require("../config"));
const { log, error: logError } = console;
/**
 * Parses input parameters
 * Reduction function inspired by: https://stackoverflow.com/a/48480895
 * @param input
 * @returns
 */
function parseInput(input) {
    const splitInput = input
        .trim()
        .split(" ")
        .map((str) => str.trim())
        .filter((str) => str.length > 0);
    return splitInput.reduce((accum, curr) => {
        if (accum.concatting) {
            accum.inputs[accum.inputs.length - 1] += " " + curr;
        }
        else {
            accum.inputs.push(curr);
        }
        if (curr.split("'").length % 2 == 0) {
            accum.concatting = !accum.concatting;
        }
        return accum;
    }, { inputs: [], concatting: false }).inputs;
}
exports.parseInput = parseInput;
/**
 * Parses a JSON input between two single quotation marks and returns a JSON object
 * @param input
 * @returns
 */
function parseJSONInput(input) {
    return JSON.parse(input.replace(/'/gm, ""));
}
exports.parseJSONInput = parseJSONInput;
/**
 * Validates that all flags input were correct
 * @param flags
 * @param cmd
 * @returns
 */
function validateFlags(flags, cmd) {
    if (!cmd.flags)
        return;
    const passedFlags = Object.keys(flags);
    const validFlags = Object.keys(cmd.flags);
    for (let i = 0; i < passedFlags.length; i++) {
        const flag = passedFlags[i];
        if (!validFlags.includes(flag)) {
            throw new Error(`Invalid flag passed: ${flag}`);
        }
    }
}
/**
 * Generalized handler function, parses any inputs and flags and calls the appropriate handler
 * @param input
 * @param flags
 * @param commands
 * @param prefix
 * @returns
 */
async function handle(input, flags, commands, prefix) {
    const arg = input.shift();
    let commandInput = [...input];
    const cmd = commands[arg ?? ""];
    if (!arg || !cmd) {
        if (!flags["help"]) {
            log(picocolors_1.default.red("Invalid command"));
            log();
        }
        await (0, cmd_1.listCommands)(commands, prefix);
        return;
    }
    else {
        if (cmd.disabled && (await cmd.disabled())) {
            log(picocolors_1.default.red("Command disabled"));
            return;
        }
        if (flags["help"] && (commandInput.length === 0 || cmd.inputs)) {
            await (0, cmd_1.printCommandHelp)(cmd, commands);
            return;
        }
        try {
            validateFlags(flags, cmd);
        }
        catch (error) {
            //Invalid flags, print out help text and return
            const { message } = error;
            logError(picocolors_1.default.red(message));
            log();
            await (0, cmd_1.printCommandHelp)(cmd, commands);
            return;
        }
        try {
            //Check if command has expected inputs
            if (cmd.inputs) {
                for (let i = 0; i < cmd.inputs.length; i++) {
                    const { requestMessage, validate, options, transform, hiddenInput, default: defaultValue } = cmd.inputs[i];
                    let userInput = commandInput[i];
                    const inputOptions = options
                        ? Array.isArray(options)
                            ? options
                            : await options()
                        : undefined;
                    userInput = await (0, common_1.validateOrRequest)(requestMessage, userInput, validate, inputOptions, hiddenInput, typeof defaultValue === 'string' ? defaultValue : await defaultValue?.());
                    if (cmd_1.exitInputs.includes(userInput))
                        throw new Error("Command exited");
                    commandInput[i] = transform ? await transform(userInput) : userInput;
                }
            }
            await cmd.handler(commandInput, flags);
        }
        catch (error) {
            console.log();
            // If its not an error then its interrupted call from inquirer to exist by user
            if (error === 'EVENT_INTERRUPTED') {
                logError(picocolors_1.default.red("Prompt has been interrupted"));
            }
            else {
                //Invalid command, print out help text
                const { message } = error;
                logError(picocolors_1.default.red(message));
                log(picocolors_1.default.red(`Use the ${picocolors_1.default.bold("--help")} flag for help`));
            }
        }
    }
}
exports.handle = handle;
/**
 * Generates a handler function given a list of commands and their prefix
 * @param commands
 * @param prefix
 * @returns A handler function
 */
function generateHandler(commands, prefix) {
    const handlerFunction = async (input, flags) => {
        await handle(input, flags, commands, prefix);
    };
    return handlerFunction;
}
exports.generateHandler = generateHandler;
/**
 * Validates an address input parameter for a command by attempting to decode it using bech32 and ensuring the prefix of the address matches the current config
 * @param addr The address to validate
 * @returns Whether the address is valid or not
 */
function validateAddressInput(addr) {
    try {
        const isValid = (0, andromeda_js_1.validateAddress)(addr, config_1.default.get("chain.addressPrefix"));
        if (!isValid) {
            throw new Error();
        }
        return isValid;
    }
    catch (error) {
        console.log();
        console.log(picocolors_1.default.red("Not a valid address"));
        return false;
    }
}
exports.validateAddressInput = validateAddressInput;
