"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.simulateMigrate = exports.simulateUploadMessage = exports.simulateInstantiationMessage = exports.simulateExecuteMessage = exports.migrateMessage = exports.instantiateMessage = exports.queryMessage = exports.uploadWasm = exports.executeMessage = exports.commands = void 0;
const proto_signing_1 = require("@cosmjs/proto-signing");
const cmd_1 = require("../cmd");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const common_1 = require("../common");
const state_1 = __importDefault(require("../state"));
const utils_1 = require("./utils");
const { client } = state_1.default;
exports.commands = {
    query: {
        handler: queryHandler,
        color: picocolors_1.default.green,
        description: "Queries a contract",
        usage: "wasm query <contract address> <query object>",
        inputs: [
            {
                requestMessage: "Input Contract Address:",
                validate: utils_1.validateAddressInput,
            },
            {
                requestMessage: "Input query:",
                validate: (input) => {
                    try {
                        (0, utils_1.parseJSONInput)(input);
                        return true;
                    }
                    catch (error) {
                        console.log();
                        console.log(picocolors_1.default.red("Invalid JSON Input"));
                        return false;
                    }
                },
            },
        ],
    },
    execute: {
        handler: executeHandler,
        color: picocolors_1.default.yellow,
        description: "Executes a wasm message",
        usage: "wasm execute <contract address> <message>",
        flags: common_1.executeFlags,
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
        inputs: [
            {
                requestMessage: "Input Contract Address:",
                validate: utils_1.validateAddressInput,
            },
            {
                requestMessage: "Input execute message:",
                validate: (input) => {
                    try {
                        (0, utils_1.parseJSONInput)(input);
                        return true;
                    }
                    catch (error) {
                        console.log();
                        console.log(picocolors_1.default.red("Invalid JSON Input"));
                        return false;
                    }
                },
            },
        ],
    },
    instantiate: {
        handler: instantiateHandler,
        color: picocolors_1.default.magenta,
        description: "Instantiates a contract by code ID",
        usage: "wasm instantiate <codeid> <instantiatemsg>",
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
        flags: common_1.instantiateFlags,
        inputs: [
            {
                requestMessage: "Input Code ID:",
                validate: (input) => {
                    try {
                        parseInt(input);
                        return true;
                    }
                    catch (error) {
                        console.log();
                        console.log(picocolors_1.default.red("Please input a valid code ID"));
                        return false;
                    }
                },
            },
            {
                requestMessage: "Input instantiate message:",
                validate: (input) => {
                    try {
                        (0, utils_1.parseJSONInput)(input);
                        return true;
                    }
                    catch (error) {
                        console.log();
                        console.log(picocolors_1.default.red("Invalid JSON Input"));
                        return false;
                    }
                },
            },
        ],
    },
    upload: {
        handler: uploadHandler,
        color: picocolors_1.default.blue,
        description: "Upload a contract wasm",
        usage: "wasm upload <wasm file>",
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
        inputs: [
            {
                requestMessage: "Input Wasm File Path:",
                validate: (input) => {
                    const filePath = path_1.default.join(process.env.PWD ?? "", input);
                    const exists = fs_1.default.existsSync(filePath);
                    if (!exists) {
                        console.log();
                        console.log(picocolors_1.default.red(`No file found at path ${filePath}`));
                        return false;
                    }
                    else {
                        return true;
                    }
                },
                transform: (input) => {
                    return path_1.default.join(process.env.PWD ?? "", input);
                },
            },
        ],
    },
    migrate: {
        handler: migrateHandler,
        color: picocolors_1.default.cyan,
        description: "Migrate a contract",
        usage: "wasm migrate <contract address> <new code id> <migrate msg>",
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
        inputs: [
            {
                requestMessage: "Input Contract Address:",
                validate: utils_1.validateAddressInput,
            },
            {
                requestMessage: "Input New Contract Code ID:",
                validate: (input) => {
                    try {
                        if (input.length === 0)
                            return false;
                        parseInt(input);
                        return true;
                    }
                    catch (error) {
                        console.log();
                        console.log(picocolors_1.default.red("Invalid Code ID"));
                        console.log();
                        return false;
                    }
                },
                transform: (input) => {
                    return parseInt(input);
                },
            },
            {
                requestMessage: "Input Migrate message:",
                validate: (input) => {
                    try {
                        (0, utils_1.parseJSONInput)(input);
                        return true;
                    }
                    catch (error) {
                        console.log();
                        console.log(picocolors_1.default.red("Invalid JSON Input"));
                        console.log();
                        return false;
                    }
                },
            },
        ],
    },
};
/**
 * Queries a contract given a query message and address
 * @param input
 */
async function queryHandler(input) {
    const [contractAddr, msg] = input;
    const parsedMsg = (0, utils_1.parseJSONInput)(msg);
    const resp = await queryMessage(contractAddr, parsedMsg);
    console.log(JSON.stringify(resp, null, 2));
}
/**
 * Executes a message on a contract give an address
 * @param input
 * @param flags
 */
async function executeHandler(input, flags) {
    const [contractAddr, msg] = input;
    const parsedMsg = (0, utils_1.parseJSONInput)(msg);
    await executeMessage(contractAddr, parsedMsg, flags); //TODO: ADD FEE FLAG
}
/**
 * Uploads a contract given a wasm file. The path provided is relative to where the CLI was started.
 * @param input
 * @param flags
 */
async function uploadHandler(input, flags) {
    const [wasmFile] = input;
    const wasmBuffer = fs_1.default.readFileSync(wasmFile);
    const wasmBinary = new Uint8Array(wasmBuffer);
    await uploadWasm(wasmBinary, flags);
}
/**
 * Instantiates a contract given a code ID and instantiation message
 * @param input
 * @param flags
 */
async function instantiateHandler(input, flags) {
    const [codeIdInput, msg] = input;
    const parsedMsg = (0, utils_1.parseJSONInput)(msg);
    const codeId = parseInt(codeIdInput);
    await instantiateMessage(codeId, parsedMsg, flags);
}
/**
 * Migrates a contract given a contract address, code ID and migrate message
 * @param input
 * @param flags
 */
async function migrateHandler(input, flags) {
    const [contractAddress, codeIdInput, msg] = input;
    const parsedMsg = (0, utils_1.parseJSONInput)(msg);
    const codeId = parseInt(codeIdInput);
    await migrateMessage(contractAddress, codeId, parsedMsg, flags);
}
/**
 * Prompts a user to attach funds to their current message
 * @returns {Coin[]}
 */
async function promptForFunds() {
    const confirmationPrompt = await (0, cmd_1.promptWithExit)({
        type: "confirm",
        message: "Would you like to add funds to this message?",
        name: "confirm",
    });
    if (confirmationPrompt?.confirm) {
        const fundsPrompt = await (0, cmd_1.promptWithExit)({
            type: "input",
            message: "Input funds to attach to this message:",
            name: "funds",
            validate: (input) => {
                try {
                    (0, proto_signing_1.parseCoins)(input);
                    return true;
                }
                catch (error) {
                    return "Invalid coin input";
                }
            },
        });
        return (0, proto_signing_1.parseCoins)(fundsPrompt.funds);
    }
    return [];
}
/**
 * Handler for executing a message. Prints all cost estimates and any flag related data. Prompts the user to confirm the message before sending.
 * Logs a transaction URL upon completion.
 * @param address
 * @param msg
 * @param flags
 * @param successMessage An optional message to print if the message is a success
 */
async function executeMessage(address, msg, flags, successMessage) {
    const { funds, memo, fee, simulate, print } = flags;
    if (print) {
        console.log(picocolors_1.default.bold("Message:"));
        console.log(JSON.stringify(msg, null, 2));
        console.log();
    }
    const msgFunds = funds && funds.length > 0 ? (0, proto_signing_1.parseCoins)(funds) : await promptForFunds();
    const feeEstimate = await simulateExecuteMessage(address, msg, memo, msgFunds);
    console.log("Transaction simulated!");
    console.log();
    logFeeEstimation(feeEstimate);
    if (simulate) {
        return;
    }
    const confirmation = await (0, cmd_1.promptWithExit)({
        type: "confirm",
        message: `Do you want to proceed?`,
        name: "confirmtx",
    });
    if (!confirmation.confirmtx) {
        console.log(picocolors_1.default.red("Transaction cancelled"));
        return;
    }
    const resp = await (0, common_1.displaySpinnerAsync)("Executing Tx...", async () => await client.execute(address, msg, fee, memo, msgFunds));
    console.log();
    console.log(picocolors_1.default.green(successMessage ?? "Transaction executed!"));
    console.log();
    (0, common_1.printTransactionUrl)(resp.transactionHash);
}
exports.executeMessage = executeMessage;
/**
 * Handler for uploading contract binary. Prints all cost estimates and any flag related data. Prompts the user to confirm the message before sending.
 * Logs a transaction URL upon completion.
 * @param binary
 * @param flags
 * @param successMessage An optional message to print if the message is a success
 * @returns
 */
async function uploadWasm(binary, flags, successMessage) {
    const { fee } = flags;
    // const feeEstimate = await simulateUploadMessage(binary);
    // console.log(successMessage ?? pc.green("Transaction simulated!"));
    // console.log();
    // logFeeEstimation(feeEstimate);
    // if (simulate) {
    //   return;
    // }
    // const confirmation = await promptWithExit({
    //   type: "confirm",
    //   message: `Do you want to proceed?`,
    //   name: "confirmtx",
    // });
    // if (!confirmation.confirmtx) {
    //   console.log(pc.red("Transaction cancelled"));
    //   return;
    // }
    const result = await (0, common_1.displaySpinnerAsync)("Uploading contract binary...", async () => await client.upload(binary, fee));
    console.log(successMessage ?? picocolors_1.default.green("Wasm uploaded!"));
    console.log();
    (0, common_1.printTransactionUrl)(result.transactionHash);
    console.log(picocolors_1.default.green(`Code ID: ${result.codeId}`));
}
exports.uploadWasm = uploadWasm;
/**
 * A handler for querying a contract.
 * @param address
 * @param msg
 * @returns The response data
 */
async function queryMessage(address, msg, loadingMessage = "Querying contract...") {
    const resp = await (0, common_1.displaySpinnerAsync)(loadingMessage, async () => await client.queryContract(address, msg));
    return resp;
}
exports.queryMessage = queryMessage;
/**
 * A handler for instantiating a contract. Prints all cost estimates and any flag related data. Prompts the user to confirm the message before sending.
 * Logs a transaction URL upon completion.
 * @param codeId
 * @param msg
 * @param flags
 * @param successMessage
 */
async function instantiateMessage(codeId, msg, flags, successMessage) {
    const { label, admin, simulate, print } = flags;
    if (print) {
        console.log(picocolors_1.default.bold("Message:"));
        console.log(JSON.stringify(msg, null, 2));
        console.log();
    }
    const feeEstimate = await simulateInstantiationMessage(codeId, msg, label ?? "Instantiation");
    console.log(successMessage ?? picocolors_1.default.green("Transaction simulated!"));
    console.log();
    logFeeEstimation(feeEstimate);
    if (simulate) {
        return;
    }
    const confirmation = await (0, cmd_1.promptWithExit)({
        type: "confirm",
        message: `Do you want to proceed?`,
        name: "confirmtx",
    });
    if (!confirmation.confirmtx) {
        console.log(picocolors_1.default.red("Transaction cancelled"));
        return;
    }
    const resp = await (0, common_1.displaySpinnerAsync)("Instantiating your contract...", async () => await client.instantiate(codeId, msg, label ?? "Instantiation", flags.fee, admin ? { admin } : undefined));
    console.log();
    console.log(successMessage ?? picocolors_1.default.green("Contract instantiated!"));
    console.log();
    (0, common_1.printTransactionUrl)(resp.transactionHash);
    console.log(`Address: ${picocolors_1.default.bold(resp.contractAddress)}`);
}
exports.instantiateMessage = instantiateMessage;
/**
 * A handler for migrating a contract. Prints all cost estimates and any flag related data. Prompts the user to confirm the message before sending.
 * Logs a transaction URL upon completion.
 * @param contractAddress
 * @param codeId
 * @param msg
 * @param flags
 * @param successMessage
 */
async function migrateMessage(contractAddress, codeId, msg, flags, successMessage) {
    const { memo, simulate } = flags;
    const feeEstimate = await simulateMigrate(contractAddress, codeId, msg);
    console.log(successMessage ?? picocolors_1.default.green("Transaction simulated!"));
    console.log();
    logFeeEstimation(feeEstimate);
    if (simulate) {
        return;
    }
    const confirmation = await (0, cmd_1.promptWithExit)({
        type: "confirm",
        message: `Do you want to proceed?`,
        name: "confirmtx",
    });
    if (!confirmation.confirmtx) {
        console.log(picocolors_1.default.red("Transaction cancelled"));
        return;
    }
    const resp = await (0, common_1.displaySpinnerAsync)("Migrating your contract...", async () => await client.migrate(contractAddress, codeId, msg, flags.fee, memo));
    console.log();
    console.log(successMessage ?? picocolors_1.default.green("Contract migrated!"));
    console.log();
    (0, common_1.printTransactionUrl)(resp.transactionHash);
    console.log(`Address: ${picocolors_1.default.bold(contractAddress)}`);
}
exports.migrateMessage = migrateMessage;
/**
 * Prints a fee estimation in human readable format.
 * @param fee
 */
function logFeeEstimation(fee) {
    console.log(picocolors_1.default.bold("Cost Estimates"));
    console.log(`Gas Used: ${fee.gas}`);
    console.log("Fee estimates:");
    for (let i = 0; i < fee.amount.length; i++) {
        const feeCoin = fee.amount[i];
        console.log(`   ${picocolors_1.default.green(`${feeCoin.amount}${feeCoin.denom}`)}`);
    }
    console.log();
}
/**
 * Simulates an execute message and returns a fee estimate
 * @param address
 * @param msg
 * @param flags
 * @returns A fee estimate for the message
 */
async function simulateExecuteMessage(address, msg, memo = "", msgFunds = []) {
    const feeEstimate = (0, common_1.displaySpinnerAsync)("Simulating Tx...", async () => await client.estimateExecuteFee(address, msg, msgFunds, undefined, memo));
    return feeEstimate;
}
exports.simulateExecuteMessage = simulateExecuteMessage;
/**
 * Simulates an instantiation message and returns a fee estimate
 * @param codeId
 * @param msg
 * @param label
 * @returns A fee estimate for the message
 */
async function simulateInstantiationMessage(codeId, msg, label) {
    const feeEstimate = (0, common_1.displaySpinnerAsync)("Simulating Instantiation Tx...", async () => await client.estimateInstantiationFee(codeId, msg, label));
    return feeEstimate;
}
exports.simulateInstantiationMessage = simulateInstantiationMessage;
/**
 * Simulates an upload message and returns a fee estimate
 * @param binary
 * @returns A fee estimate for the message
 */
async function simulateUploadMessage(binary) {
    const feeEstimate = (0, common_1.displaySpinnerAsync)("Simulating Upload Tx...", async () => await client.estimateUploadFee(binary));
    return feeEstimate;
}
exports.simulateUploadMessage = simulateUploadMessage;
/**
 * Simulates a migrate message and returns a fee estimate
 * @param address
 * @param codeId
 * @param msg
 * @returns A fee estimate for the message
 */
async function simulateMigrate(address, codeId, msg) {
    const feeEstimate = (0, common_1.displaySpinnerAsync)("Simulating Migrate Tx...", async () => await client.estimateMigrateFee(address, codeId, msg));
    return feeEstimate;
}
exports.simulateMigrate = simulateMigrate;
exports.default = exports.commands;
