"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const picocolors_1 = __importDefault(require("picocolors"));
const common_1 = require("../../common");
const schema_1 = require("../../schema");
const state_1 = __importDefault(require("../../state"));
const gql_1 = __importDefault(require("../gql"));
const utils_1 = require("../utils");
const wasm_1 = require("../wasm");
const db_1 = __importDefault(require("./db"));
const modules_1 = __importDefault(require("./modules"));
const operators_1 = __importDefault(require("./operators"));
const { client, wallets } = state_1.default;
// The ADO DB has several subcommands, see `db.ts`
const dbHandler = (0, utils_1.generateHandler)(db_1.default);
// Operators have several subcommands, see 'operators.ts'
const operatorsHandler = (0, utils_1.generateHandler)(operators_1.default);
// Modules have several subcommands, see 'modules.ts'
const modulesHandler = (0, utils_1.generateHandler)(modules_1.default);
const commands = {
    db: {
        handler: dbHandler,
        usage: "ado db",
        description: "Allows querying the on chain ADO DB",
        color: picocolors_1.default.white,
    },
    create: {
        handler: createHandler,
        usage: "ado create <type>",
        description: "Creates an ADO by given type",
        flags: common_1.instantiateFlags,
        color: picocolors_1.default.green,
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
        inputs: [
            {
                requestMessage: "Input the ADO type:",
                validate: async (input) => {
                    try {
                        await client.os.schema.getSchemaFromAdoType(input);
                        return true;
                    }
                    catch (error) {
                        const { message } = error;
                        if (message.includes("u64 not found")) {
                            console.log(picocolors_1.default.red("Invalid ADO Type"));
                        }
                        else {
                            console.log(picocolors_1.default.red(message));
                        }
                        return false;
                    }
                },
                options: async () => {
                    try {
                        const adoTypes = (0, common_1.displaySpinnerAsync)("Fetching ADO types...", async () => await client.os.adoDB.getAllADO());
                        return adoTypes ?? [];
                    }
                    catch (error) {
                        return [];
                    }
                },
                transform: (input) => input.toLowerCase(),
            },
        ],
    },
    execute: {
        handler: executeHandler,
        usage: "ado execute <address>",
        description: "Executes a message on an ADO by given address",
        flags: common_1.executeFlags,
        color: picocolors_1.default.blue,
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
        inputs: [
            {
                requestMessage: "Input the ADO Address:",
                validate: utils_1.validateAddressInput,
            },
        ],
    },
    query: {
        handler: queryHandler,
        usage: "ado query <address>",
        description: "Queries an ADO by given address",
        color: picocolors_1.default.magenta,
        inputs: [
            {
                requestMessage: "Input the ADO Address:",
                validate: utils_1.validateAddressInput,
            },
        ],
    },
    info: {
        handler: queryInfoHandler,
        usage: "ado info <address>",
        description: "Queries the info of ADO for a given address",
        color: picocolors_1.default.yellow,
        inputs: [
            {
                requestMessage: "Input the ADO Address:",
                validate: utils_1.validateAddressInput,
            },
        ],
    },
    list: {
        ...gql_1.default.assets,
        usage: "ado list",
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
        color: picocolors_1.default.cyan,
    },
    transfer: {
        handler: transferHandler,
        usage: "ado transfer <address> <new owner address>",
        description: "Transfers ownership of an ADO",
        color: picocolors_1.default.green,
        inputs: [
            {
                requestMessage: "Input the ADO Address:",
                validate: utils_1.validateAddressInput,
            },
            {
                requestMessage: "Input the address of the new owner:",
                validate: utils_1.validateAddressInput,
            },
        ],
    },
    operators: {
        handler: operatorsHandler,
        usage: "ado operators",
        description: "Allows management of operators for an ADO",
        color: picocolors_1.default.blue,
    },
    modules: {
        handler: modulesHandler,
        usage: "ado modules",
        description: "Allows management of modules for an ADO",
        color: picocolors_1.default.yellow,
    },
    resolvepath: {
        handler: resolvePathHandler,
        color: picocolors_1.default.cyan,
        description: "Gets the address of the specified path",
        usage: "ado resolvepath",
        inputs: [
            {
                requestMessage: "Input the path:",
                validate: (input) => {
                    if (input.length === 0)
                        return false;
                    return true;
                },
            },
        ],
        flags: common_1.executeFlags,
    },
    addpath: {
        handler: addPathHandler,
        color: picocolors_1.default.magenta,
        description: "Registers an ADO component to the path",
        usage: "ado addpath",
        inputs: [
            {
                requestMessage: "Input the ADO componet Address:",
                validate: utils_1.validateAddressInput,
            },
            {
                requestMessage: "Input the name:",
                validate: (input) => {
                    if (input.length === 0)
                        return false;
                    return true;
                },
            },
        ],
        flags: common_1.executeFlags,
    },
    addparentpath: {
        handler: addParentPathHandler,
        color: picocolors_1.default.magenta,
        description: "Registers the child's path relative to the parent",
        usage: "ado addparentpath",
        inputs: [
            {
                requestMessage: "Input the Parent Address:",
                validate: utils_1.validateAddressInput,
            },
            {
                requestMessage: "Input the name:",
                validate: (input) => {
                    if (input.length === 0)
                        return false;
                    return true;
                },
            },
        ],
        flags: common_1.executeFlags,
    },
    subdir: {
        handler: subDirHandler,
        color: picocolors_1.default.cyan,
        description: "Gets the sub directory of the specified path",
        usage: "ado subdir",
        inputs: [
            {
                requestMessage: "Input the path:",
                validate: (input) => {
                    if (input.length === 0)
                        return false;
                    return true;
                },
            },
        ],
        flags: common_1.executeFlags,
    },
    paths: {
        handler: pathsHandler,
        color: picocolors_1.default.yellow,
        description: "Gets the paths of an ADO",
        usage: "ado paths",
        inputs: [
            {
                requestMessage: "Input the Address:",
                validate: utils_1.validateAddressInput,
            },
        ],
        flags: common_1.executeFlags,
    },
};
/**
 * Creates an ADO by given type
 * @param input
 * @param flags
 */
async function createHandler(input, flags) {
    const [type] = input;
    const codeId = await client.os.adoDB.getCodeId(type);
    const adoSchema = await (0, common_1.displaySpinnerAsync)(`Fetching schema for ${type}-${codeId}...`, async () => await client.os.schema.getSchemaFromCodeId(codeId));
    const msg = await (0, schema_1.promptInstantiateMsg)(adoSchema.schema.instantiate
        ? adoSchema.schema.instantiate
        : adoSchema.schema, codeId);
    await (0, wasm_1.instantiateMessage)(codeId, msg, flags);
}
/**
 * Queries an ADO for its codeId by address
 * @param address The address of the ADO
 * @returns The codeId of ADO the contract is, errors if address is not a contract
 */
async function queryCodeId(address) {
    const { codeId } = await client.chainClient.queryClient.getContract(address);
    return codeId;
}
/**
 * Queries an ADO for its type by address
 * @param address The address of the ADO
 * @returns The type of ADO the contract is, errors if the contract is not an ADO
 */
async function queryADOType(address) {
    const queryMsg = client.ado.typeQuery();
    const { ado_type } = await (0, wasm_1.queryMessage)(address, queryMsg);
    return ado_type;
}
/**
 * Queries an ADO for its schema by address
 * @param address The address of the ADO
 * @returns Schema for the ado
 */
async function queryAdoSchema(address) {
    try {
        // First try to get the schema using codeId as codeId are unique
        const codeId = await queryCodeId(address);
        const schema = await client.os.schema.getSchemaFromCodeId(codeId);
        return schema;
    }
    catch (err) {
        // If codeId schema fetch fail, try to get the adoType and check the codeId for it in adodb
        console.log(`Schema not found using Code Id, falling back to Ado Type`);
        const adoType = await queryADOType(address);
        console.log(adoType);
        const schema = await client.os.schema.getSchemaFromAdoType(adoType);
        return schema;
    }
}
/**
 * Executes a chosen message on an ADO by its address
 * @param input
 * @param flags
 */
async function executeHandler(input, flags) {
    const [address] = input;
    const adoSchema = await (0, common_1.displaySpinnerAsync)("Fetching schema...", async () => await queryAdoSchema(address).catch(() => { throw new Error(`Not a valid ADO`); }));
    const msg = await (0, schema_1.promptQueryOrExecuteMessage)(adoSchema.schema.execute
        ? adoSchema.schema.execute
        : adoSchema.schema, adoSchema.key);
    await (0, wasm_1.executeMessage)(address, msg, flags);
}
/**
 *  Queries an ADO by its address
 * @param input
 */
async function queryHandler(input) {
    const [address] = input;
    let codeId = -1;
    try {
        codeId = await queryCodeId(address);
    }
    catch (error) {
        console.error(picocolors_1.default.red("Contract is not a valid ADO"));
        return;
    }
    const adoSchema = await (0, common_1.displaySpinnerAsync)("Fetching schema...", async () => await client.os.schema.getSchemaFromCodeId(codeId));
    const msg = await (0, schema_1.promptQueryOrExecuteMessage)(adoSchema.schema.query
        ? adoSchema.schema.query
        : adoSchema.schema, adoSchema.key);
    const resp = await (0, wasm_1.queryMessage)(address, msg);
    console.log(JSON.stringify(resp, null, 2));
}
/**
 * Queries an ADO for its info by address
 * @param input
 */
async function queryInfoHandler(input) {
    const [address] = input;
    const { type, version, owner, publisher, createdHeight } = await (0, common_1.displaySpinnerAsync)("Querying ADO info...", async () => {
        const info = [
            client.ado.getType(address),
            client.ado.getVersion(address),
            client.ado.getOwner(address),
            client.ado.getPublisher(address),
            client.ado.getCreatedHeight(address),
        ];
        const [type, version, owner, publisher, createdHeight] = await Promise.all(info);
        return {
            type,
            version,
            owner,
            publisher,
            createdHeight,
        };
    });
    console.log();
    console.log(picocolors_1.default.bold("ADO Info"));
    console.log(`${picocolors_1.default.bold("Type:")} ${type}`);
    console.log(`${picocolors_1.default.bold("Version:")} v${version}`);
    console.log(`${picocolors_1.default.bold("Owner:")} ${owner}`);
    console.log(`${picocolors_1.default.bold("Publisher:")} ${publisher}`);
    console.log(`${picocolors_1.default.bold("Created Height:")} ${createdHeight}`);
}
/**
 * Transfers ownership of an ADO
 * @param input
 * @param flags
 */
async function transferHandler(input, flags) {
    const [address, recipient] = input;
    const owner = await client.ado.getOwner(address);
    const currWallet = wallets.currentWalletAddress;
    if (!currWallet || owner !== currWallet)
        throw new Error("Cannot transfer an ADO you do not own");
    const msg = client.ado.updateOwnerMsg(recipient);
    await (0, wasm_1.executeMessage)(address, msg, flags, "ADO Transferred!");
}
/**
 * Queries to get the address of the specified path
 * @param input
 * @param flags
 */
async function resolvePathHandler(input) {
    if (!client.os.vfs?.address)
        throw new Error("VFS has no assigned address");
    const [path] = input;
    const resp = await client.os.vfs?.resolvePath(path);
    console.log(JSON.stringify(resp, null, 2));
}
/**
 * Registers an ADO to the path.
 * @param input
 * @param flags
 */
async function addPathHandler(input, flags) {
    if (!client.os.vfs?.address)
        throw new Error("VFS has no assigned address");
    const [address, name] = input;
    const msgAddPath = client.os.vfs?.addPathMsg(name, address);
    await (0, wasm_1.executeMessage)(client.os.vfs?.address, msgAddPath, flags, "Registered the given ado to the path!"); //TODO: ADD FEE FLAG
}
/**
 * Registers the child's path relative to the parent.
 * @param input
 * @param flags
 */
async function addParentPathHandler(input, flags) {
    if (!client.os.vfs?.address)
        throw new Error("VFS has no assigned address");
    const [parent_address, name] = input;
    const msgAddParentPath = client.os.vfs?.addParentPathMsg(name, parent_address);
    await (0, wasm_1.executeMessage)(client.os.vfs?.address, msgAddParentPath, flags, "Assigned name to the given parent!"); //TODO: ADD FEE FLAG
}
/**
 * Queries to get the sub directories of the specified path
 * @param input
 * @param flags
 */
async function subDirHandler(input) {
    if (!client.os.vfs?.address)
        throw new Error("VFS has no assigned address");
    const [path] = input;
    const resp = await client.os.vfs?.subDir(path);
    console.log(JSON.stringify(resp, null, 2));
}
/**
 * Queries to get the paths of an ADO
 * @param input
 * @param flags
 */
async function pathsHandler(input) {
    if (!client.os.vfs?.address)
        throw new Error("VFS has no assigned address");
    const [address] = input;
    const resp = await client.os.vfs?.paths(address);
    console.log(JSON.stringify(resp, null, 2));
}
exports.default = commands;
