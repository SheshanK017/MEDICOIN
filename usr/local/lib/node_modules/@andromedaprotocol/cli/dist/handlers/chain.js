"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.newConfigHandler = void 0;
const andromeda_js_1 = require("@andromedaprotocol/andromeda.js");
const cli_table_1 = __importDefault(require("cli-table"));
const picocolors_1 = __importDefault(require("picocolors"));
const cmd_1 = require("../cmd");
const common_1 = require("../common");
const config_1 = __importDefault(require("../config"));
const storage_1 = require("../config/storage");
const state_1 = __importDefault(require("../state"));
const wallet_1 = require("./wallet");
const STORAGE_FILE = "chainConfigs.json";
const commands = {
    config: {
        handler: configPrintHandler,
        color: picocolors_1.default.white,
        description: "Displays current chain config",
        usage: "chain config",
    },
    list: {
        handler: listConfigsHandler,
        color: picocolors_1.default.blue,
        description: "Lists all the currently saved configs",
        usage: "chain list",
    },
    use: {
        handler: useConfigHandler,
        color: picocolors_1.default.yellow,
        description: "Swap to a saved config",
        usage: "chain use <chain ID>",
        inputs: [
            {
                requestMessage: "Input the chain ID to use:",
                options: async () => {
                    const configs = await (0, common_1.displaySpinnerAsync)("Loading configs...", queryAllConfigsSafe);
                    return configs.map((conf) => conf.name);
                },
            },
        ],
    },
    get: {
        handler: configGetHandler,
        color: picocolors_1.default.cyan,
        description: "Displays current value for a given key",
        usage: "chain get <key>",
    },
    set: {
        handler: configSetHandler,
        color: picocolors_1.default.black,
        description: "Sets the value for a given config key",
        usage: "chain set <key> <value>",
        disabled: async () => typeof (await queryChainConfigSafe(config_1.default.get("chain.name"))) !==
            "undefined",
        inputs: [
            {
                requestMessage: "Input Config Key:",
            },
            {
                requestMessage: "Input Value:",
            },
        ],
    },
    new: {
        handler: newConfigHandler,
        color: picocolors_1.default.green,
        description: "Creates a new config",
        usage: "chain new <name>",
        inputs: [
            {
                requestMessage: "Input Config Name:",
                validate: validateNewConfigName,
            },
        ],
    },
    copy: {
        handler: copyConfigHandler,
        color: picocolors_1.default.magenta,
        description: "Creates a copy of a current config",
        usage: "chain copy <current config name> <new config name>",
        inputs: [
            {
                requestMessage: "Input Current Config Name:",
                validate: async (input) => {
                    const config = await getCLIChainConfig(input);
                    if (!config) {
                        console.log();
                        console.log(picocolors_1.default.red("Config does not exist"));
                        return false;
                    }
                    return true;
                },
                options: async () => [
                    ...localConfigs.map(({ name }) => name),
                    ...(await queryAllConfigsSafe()).map(({ name }) => name),
                ],
            },
            {
                requestMessage: "Input New Config Name:",
                validate: validateNewConfigName,
            },
        ],
    },
    rm: {
        handler: removeConfigHandler,
        color: picocolors_1.default.red,
        description: "Removes a config by name or chain ID",
        usage: "chain rm <config name>",
        inputs: [
            {
                requestMessage: "Select config to remove:",
                validate: async (input) => {
                    const config = await getCLIChainConfig(input);
                    if (!config) {
                        console.log();
                        console.log(picocolors_1.default.red(`Config ${input} not found`));
                        return false;
                    }
                    return true;
                },
                options: async () => [...localConfigs.map(({ name }) => name)],
            },
        ],
    },
};
/**
 * Validates a new config name, ensures that the config name is not already taken
 * @param input
 * @returns
 */
async function validateNewConfigName(input) {
    if (input.length === 0)
        return false;
    try {
        const config = await getCLIChainConfig(input);
        if (config) {
            console.log();
            console.log(picocolors_1.default.red("Config already exists with that name"));
            return false;
        }
    }
    catch (error) {
        const { message } = error;
        if (message.includes("not found"))
            return true;
        console.error(message);
        return false;
    }
    return true;
}
/**
 * A safe query for all chain configs, returns an empty array and prints a message if something went wrong fetching the chain configs
 * @returns
 */
async function queryAllConfigsSafe() {
    try {
        return await (0, andromeda_js_1.queryAllChainConfigs)();
    }
    catch (error) {
        console.error(picocolors_1.default.red("Something went wrong fetching chain configs"));
        return [];
    }
}
/**
 * A safe query for getting a chain config
 * @returns The relevant chain config if it exists
 */
async function queryChainConfigSafe(identifier) {
    try {
        const config = await (0, andromeda_js_1.queryChainConfig)(identifier);
        return config;
    }
    catch (error) {
        const { message } = error;
        if (message.includes("not found")) {
            return undefined;
        }
        else {
            throw error;
        }
    }
}
// Used for when the user creates their own config
let localConfigs = [];
/**
 * Loads all local configs from storage
 */
function loadLocalConfigs() {
    try {
        if (!(0, storage_1.storageFileExists)(STORAGE_FILE)) {
            (0, storage_1.writeStorageFile)(STORAGE_FILE, JSON.stringify([]));
            return;
        }
        const loadedConfigsBuffer = (0, storage_1.loadStorageFile)(STORAGE_FILE);
        localConfigs = JSON.parse(loadedConfigsBuffer.toString());
    }
    catch (error) {
        console.error("Problem loading local chain configs");
        console.error(error);
    }
}
loadLocalConfigs();
/**
 * Gets the description of a given key from config
 * @param key
 * @returns The description of the given key
 */
function getConfigDoc(key) {
    const schema = JSON.parse(config_1.default.getSchemaString());
    const properties = schema["_cvtProperties"]["chain"]["_cvtProperties"];
    if (!properties[key])
        return "";
    return properties[key].doc;
}
/**
 * Gets a config by a given name/chain ID.
 * Includes andromeda.js configs and locally saved configs.
 * @param identifier The config name or chain ID
 * @returns The respective config
 */
async function getCLIChainConfig(identifier) {
    try {
        const config = (await queryChainConfigSafe(identifier)) ??
            localConfigs.find((config) => config.name === identifier || config.chainId === identifier);
        return config;
    }
    catch (error) {
        throw error;
    }
}
/**
 * Prints a config in table format. If a key is provided only the given key is printed.
 * @param config
 * @param keyToPrint Optional: Key to print
 */
async function printConfig(config, keyToPrint) {
    const configTable = new cli_table_1.default(common_1.logTableConfig);
    configTable.push([picocolors_1.default.bold("Key"), picocolors_1.default.bold("Value"), picocolors_1.default.bold("Description")]);
    const trimmedKey = keyToPrint?.trim();
    let keys = Object.keys(config);
    if (trimmedKey && trimmedKey.length > 0) {
        if (!keys.includes(trimmedKey)) {
            throw new Error(`Invalid config key, try ${picocolors_1.default.white("chain get")} to see a list of valid keys`);
        }
        keys = [trimmedKey];
    }
    keys.forEach((key) => {
        if (key === "nullable")
            return;
        const val = config[key];
        configTable.push([
            key,
            val && (typeof val !== "string" || val.length > 0)
                ? val
                : "<unset>",
            getConfigDoc(key),
        ]);
    });
    console.log(picocolors_1.default.green("Current chain config"));
    console.log();
    console.log(configTable.toString());
}
/**
 * Sets the value for a given key in config
 * @param key
 * @param value
 */
async function setKey(key, value) {
    const trimmedKey = key.trim();
    const trimmedValue = value.trim();
    if (!config_1.default.has(`chain.${trimmedKey}`)) {
        throw new Error(`Invalid config key, try ${picocolors_1.default.white("chain list")} to see a list of valid keys`);
    }
    const name = config_1.default.get("chain.name");
    config_1.default.set(`chain.${trimmedKey}`, trimmedValue);
    const localConfig = localConfigs.find(({ name: localConfigName }) => localConfigName === name);
    // Save any updates to local configs
    if (localConfig) {
        localConfigs = localConfigs.map((config) => config.name === name ? { ...config, [trimmedKey]: trimmedValue } : config);
        (0, storage_1.writeStorageFile)(STORAGE_FILE, JSON.stringify(localConfigs));
    }
}
/**
 * Prints all available config names/chain IDs
 */
async function listConfigsHandler() {
    const configTable = new cli_table_1.default(common_1.logTableConfig);
    configTable.push([picocolors_1.default.bold("Name"), picocolors_1.default.bold("Chain ID")]);
    [...(await queryAllConfigsSafe()), ...localConfigs].forEach((chainConfig) => config_1.default.get("chain.name") === chainConfig.name
        ? configTable.push([
            picocolors_1.default.green(chainConfig.name),
            picocolors_1.default.green(chainConfig.chainId),
        ])
        : configTable.push([chainConfig.name, chainConfig.chainId]));
    console.log(configTable.toString());
}
/**
 * Swaps the currently used config by name/chain ID/config index
 * @param input
 */
async function useConfigHandler(input) {
    if (input.length === 0) {
        throw new Error("Invalid input");
    }
    const [chainId] = input;
    const chainConfig = await (0, common_1.displaySpinnerAsync)("Loading config...", async () => await getCLIChainConfig(chainId));
    if (!chainConfig) {
        throw new Error(`No chain config for chain ID: ${chainId}`);
    }
    config_1.default.set("chain", chainConfig);
    console.log(picocolors_1.default.green(`Config loaded!`));
    const wallet = state_1.default.wallets.currentWallet;
    if (wallet) {
        // Set current wallet also connects the client
        await (0, wallet_1.setCurrentWallet)(wallet);
    }
    else {
        // If no wallet, connect the client without a signer
        await (0, common_1.displaySpinnerAsync)("Connecting client...", async () => await state_1.default.connectClient());
    }
}
/**
 * Prints a config or just a key within the config if it is provided
 * @param input
 */
async function configGetHandler(input) {
    const [key] = input;
    await printConfig(config_1.default.get("chain"), key);
}
/**
 * Sets a value within the config by a given key
 * @param input
 */
async function configSetHandler(input) {
    const [key, value] = input;
    // const name = config.get("chain.name");
    // if (configs.some((config) => config.name === name))
    //   throw new Error(
    //     "Cannot edit this config, please create a new config if you wish to make changes"
    //   );
    await setKey(key, value);
}
/**
 * Prints the entire config
 */
async function configPrintHandler() {
    await printConfig(config_1.default.get("chain"));
}
/**
 * Generates a new config from several prompts
 * @param input
 */
async function newConfigHandler(input) {
    const [name] = input;
    const questions = [
        {
            name: "chainName",
            message: "Input the chain name:",
            type: "input",
            validate: (input) => input.length > 0,
        },
        {
            name: "chainId",
            message: "Input the Chain ID:",
            type: "input",
            validate: (input) => input.length > 4 ? true : "Invalid Chain ID",
        },
        {
            name: "chainUrl",
            message: "Input the Chain URL:",
            type: "input",
            validate: (input) => {
                const regex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/;
                return regex.test(input) ? true : "Invalid URL";
            },
        },
        {
            name: "chainType",
            message: "Select the chain type:",
            type: "list",
            choices: ["mainnet", "testnet"],
            validate: (input) => input.length > 0,
        },
        {
            name: "registryAddress",
            message: "Input the address of the Andromeda Registry for this chain (optional):",
            type: "input",
        },
        {
            name: "addressPrefix",
            message: "Input the prefix for any addresses on this chain:",
            type: "input",
            validate: (input) => input.length >= 4 ? true : "Invalid Address Prefix",
        },
        {
            name: "defaultFee",
            message: "Input the default fee for the chain (e.g. 0.025ujunox):",
            type: "input",
            validate: (input) => {
                const regex = /^[0-9]+\.[0-9]+[a-z]{2,}$/gm;
                return regex.test(input) ? true : "Invalid fee";
            },
        },
    ];
    // Any type to allow construction
    let config = await (0, cmd_1.promptWithExit)(questions);
    const fullConfig = {
        ...config,
        name,
        blockExplorerAddressPages: [],
        blockExplorerTxPages: [],
    };
    localConfigs.push(fullConfig);
    (0, storage_1.writeStorageFile)(STORAGE_FILE, JSON.stringify(localConfigs));
    await useConfigHandler(input);
}
exports.newConfigHandler = newConfigHandler;
/**
 * Copies a currently stored config by name/chainID
 * @param input
 */
async function copyConfigHandler(input) {
    const [oldConfigName, newConfigName] = input;
    const oldConfig = await getCLIChainConfig(oldConfigName);
    if (!oldConfig)
        throw new Error(`Config '${oldConfigName}' not found`);
    const newConfig = { ...oldConfig, name: newConfigName };
    localConfigs.push(newConfig);
    (0, storage_1.writeStorageFile)(STORAGE_FILE, JSON.stringify(localConfigs));
    await useConfigHandler([newConfigName]);
}
/**
 * Removes a config by name/chain ID. Default configs cannot be removed.
 * @param input
 */
async function removeConfigHandler(input) {
    const [configName] = input;
    const defaultConfig = await queryChainConfigSafe(configName);
    if (defaultConfig)
        throw new Error("Cannot remove a default config");
    const localConfig = localConfigs.find(({ name, chainId }) => name === configName || chainId === configName);
    if (!localConfig)
        throw new Error(`Config '${configName}' not found`);
    localConfigs = localConfigs.filter(({ name, chainId }) => name !== configName && chainId !== configName);
    (0, storage_1.writeStorageFile)(STORAGE_FILE, JSON.stringify(localConfigs));
    if (localConfig.name === config_1.default.get("chain.name")) {
        const replacementConfig = await (0, cmd_1.promptWithExit)({
            type: "list",
            choices: [
                ...localConfigs.map(({ name }) => name),
                ...(await queryAllConfigsSafe()).map(({ name }) => name),
            ],
            message: "Select new config to use:",
            name: "replacementconfig",
        });
        await useConfigHandler([replacementConfig.replacementconfig]);
    }
}
exports.default = commands;
