"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.promptWithExit = exports.printCommandHelp = exports.listCommands = exports.ask = exports.title = exports.baseCommands = exports.exitInputs = void 0;
const picocolors_1 = __importDefault(require("picocolors"));
const cli_table_1 = __importDefault(require("cli-table"));
const figlet_1 = __importDefault(require("figlet"));
const gradient_string_1 = __importDefault(require("gradient-string"));
const inquirer_1 = __importDefault(require("inquirer"));
const common_1 = require("./common");
const handlers_1 = require("./handlers");
const state_1 = __importDefault(require("./state"));
// Require package.json to print version
const npmPackage = require("../package.json");
/**
 * Valid inputs to exit a prompt
 */
exports.exitInputs = [".exit", ".quit", ".e", ".q", "exit"];
/**
 * Top level commands
 */
exports.baseCommands = {
    exit: {
        handler: () => process.exit(0),
        description: "Exits the CLI",
        color: picocolors_1.default.red,
        usage: "exit",
    },
    help: {
        handler: async () => {
            return await listCommands(exports.baseCommands);
        },
        description: "Lists all valid commands",
        color: picocolors_1.default.green,
        usage: "help",
    },
    clear: {
        handler: async () => {
            console.clear();
            await title();
        },
        description: "Clears the terminal",
        color: picocolors_1.default.white,
        usage: "clear",
    },
    wallet: {
        handler: handlers_1.walletHandler,
        description: "Manage wallets",
        color: picocolors_1.default.blue,
        usage: "wallet <cmd>",
    },
    chain: {
        handler: handlers_1.chainHandler,
        description: "Manage Chain Config",
        color: picocolors_1.default.yellow,
        usage: "chain <cmd>",
    },
    wasm: {
        handler: handlers_1.wasmHandler,
        description: "Send CosmWasm messages to the chain",
        color: picocolors_1.default.cyan,
        usage: "wasm <cmd>",
        disabled: () => !state_1.default.client.isConnected,
    },
    tx: {
        handler: handlers_1.txHandler,
        description: "Query transactions",
        color: picocolors_1.default.magenta,
        usage: "tx <cmd>",
        disabled: () => !state_1.default.client.isConnected,
    },
    ado: {
        handler: handlers_1.adoHandler,
        description: "Query and execute on an ADO",
        color: picocolors_1.default.red,
        usage: "ado <cmd>",
        disabled: () => !state_1.default.client.isConnected,
    },
    bank: {
        handler: handlers_1.bankHandler,
        description: "Send tokens or query balances",
        color: picocolors_1.default.green,
        usage: "bank <cmd>",
        disabled: () => !state_1.default.client.isConnected,
    },
    gql: {
        handler: handlers_1.gqlHandler,
        description: "Query using the Andromeda GraphQL service",
        color: picocolors_1.default.magenta,
        usage: "gql <cmd>",
        disabled: () => !state_1.default.client.isConnected,
    },
    version: {
        handler: async () => {
            console.log(`Version: ${npmPackage.version}`);
        },
        description: "Prints the current CLI version",
        color: picocolors_1.default.cyan,
        usage: "version",
    },
    user: {
        handler: handlers_1.userHandler,
        description: "Manage user",
        color: picocolors_1.default.blue,
        usage: "user <cmd>",
        disabled: () => typeof state_1.default.wallets.currentWallet === "undefined",
    },
};
/**
 * Prints the Andromeda CLI title
 */
async function title() {
    console.clear();
    const msg = "Andromeda CLI";
    (0, figlet_1.default)(msg, (_err, data) => {
        console.log((0, gradient_string_1.default)("blue", "purple", "red", "orange").multiline(data));
    });
    console.log();
    console.log(picocolors_1.default.red(picocolors_1.default.bold("The CLI is currently in beta. If you experience any issues or would like to provide feedback you can do so here: https://github.com/andromedaprotocol/andromeda.js/issues")));
    console.log(picocolors_1.default.blue(`Terms & Agreements: ${picocolors_1.default.bold("https://github.com/andromedaprotocol/andromeda-core/blob/development/LICENSE/LICENSE.md")}`));
    await (0, common_1.sleep)(20);
}
exports.title = title;
/**
 * Prompt the user for input
 * @param defaultValue
 * @returns The user's input
 */
async function ask(defaultValue = "") {
    const question = {
        name: "command",
        type: "command",
        message: `${state_1.default.CLIPrefix}>`,
        default: defaultValue,
        context: 10,
        short: true,
        autoCompletion: (input) => [...handlers_1.allCommands, ...Object.keys(exports.baseCommands)].filter((command) => {
            const commandSplit = command.split(" ");
            if (input.length === 0) {
                return commandSplit.length === 1;
            }
            return command.includes(input);
        }),
    };
    const prompt = inquirer_1.default.prompt(question);
    const answers = await prompt;
    return answers;
}
exports.ask = ask;
// Alias for simpler logging
const log = console.log;
/**
 * Prints all commands in a table for a given commands object
 * @param commands
 * @param prefix The prefix for all commands, for example `ado create` would have a prefix of `ado`
 */
async function listCommands(commands, prefix) {
    const commandsArray = Object.keys(commands);
    const commandTable = new cli_table_1.default({
        ...common_1.logTableConfig,
        colWidths: [2],
    });
    //Commands are sorted alphabetically with `exit` being the last
    const sortedCommands = commandsArray.sort((a, b) => a === "exit" ? -1 : a > b ? 1 : -1);
    //Errors produced when generating command list
    //Determining if a command is disabled may require asynchronous actions that can fail
    let errors = [];
    for (let i = 0; i < sortedCommands.length; i++) {
        const cmdName = sortedCommands[i];
        const cmd = commands[cmdName];
        try {
            const disabled = cmd.disabled && (await cmd.disabled());
            if (!disabled)
                commandTable.push(["", cmd.color(cmdName), cmd.description ?? ""]);
        }
        catch (error) {
            errors.push(error);
        }
    }
    if (prefix) {
        log(`Usage:`);
        log(picocolors_1.default.green(`${prefix ? `${prefix} ` : ""}[cmd]`));
        log();
    }
    log(`Valid commands:`);
    log(commandTable.toString());
    //Log any errors produced when generating command list
    errors.forEach((error) => console.error(picocolors_1.default.red(error)));
    log();
}
exports.listCommands = listCommands;
/**
 * Prints help information for a given command
 * @param cmd
 */
async function printCommandHelp(cmd, commands = {}) {
    const { description, usage } = cmd;
    log(picocolors_1.default.bold(description));
    log();
    log("Usage:");
    log(picocolors_1.default.green(usage));
    if (cmd.flags) {
        log();
        log("Valid flags:");
        const flagTable = new cli_table_1.default(common_1.logTableConfig);
        const flags = Object.keys(cmd.flags);
        flags.forEach((flag) => {
            flagTable.push([
                picocolors_1.default.green(`--${flag}`),
                cmd.flags[flag].description,
                cmd.flags[flag].usage ?? "",
            ]);
        });
        flagTable.push([
            picocolors_1.default.green("--help"),
            "Displays info about the current command",
            "",
        ]);
        log(flagTable.toString());
    }
    log();
    if (Object.keys(commands).length > 0)
        await listCommands(commands);
    log(picocolors_1.default.bold(`Any request inputs can be exited using one of the following inputs: ${exports.exitInputs.join(", ")}`));
    log(picocolors_1.default.bold(picocolors_1.default.cyan("Documentation can be found here: https://docs.andromedaprotocol.io/andromeda/andromeda-cli/")));
    log();
}
exports.printCommandHelp = printCommandHelp;
/**
 * A wrapped around inquirer that allows the user to exit a prompt
 * @param questionDefinition
 * @returns
 */
async function promptWithExit(questionDefinition) {
    const transformQuestion = (question) => {
        const mappedQuestion = {
            ...question,
            validate: async (input) => {
                // Always allow exit
                if (exports.exitInputs.includes(input))
                    return true;
                return question.validate ? question.validate(input) : true;
            },
        };
        // If the question is multiple choice include an exit choice
        if (mappedQuestion.type === "list" || mappedQuestion.type === "rawlist") {
            mappedQuestion.choices = [
                ...mappedQuestion.choices,
                { name: picocolors_1.default.red("exit"), value: "exit" },
            ];
        }
        return mappedQuestion;
    };
    // Map questions to include exit prompt
    const questions = (Array.isArray(questionDefinition)
        ? questionDefinition
        : [questionDefinition]).map(transformQuestion);
    // Store all answers
    const answers = {};
    for (let i = 0; i < questions.length; i++) {
        const question = questions[i];
        const resp = await inquirer_1.default.prompt(question);
        // If the user selects exit then throw exit error
        if (exports.exitInputs.includes(resp[question.name]))
            throw new Error("Command exited");
        answers[question.name] = resp[question.name];
    }
    return answers;
}
exports.promptWithExit = promptWithExit;
